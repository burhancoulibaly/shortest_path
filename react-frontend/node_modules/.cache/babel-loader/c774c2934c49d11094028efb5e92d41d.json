{"ast":null,"code":"class FibonacciHeap {\n  constructor() {\n    this.insert = node => {\n      this._rootList.push(node);\n\n      if (this._rootList.length > 1) {\n        const node1 = this._rootList[this._rootList - 2];\n        const node2 = this._rootList[this._rootList - 1];\n        node2.setRight(node1.getRight());\n        node1.getRight().setLeft(node2);\n        node1.setRight(node2);\n        node2.setLeft(node1);\n      } else {\n        const node1 = this._rootList[0];\n        node1.setRight(node1);\n        node1.setLeft(node1);\n      }\n\n      if (this._min < node.getVal()) {\n        this._min = node;\n      }\n    };\n\n    this.peek = () => {\n      return this._min;\n    };\n\n    this.extractMin = () => {\n      const min = this._min;\n\n      if (min) {\n        min.getChild().forEach((node, index) => {\n          node.setParent(null);\n          this.insert(node);\n        });\n\n        if (min === min.getRight()) {\n          this._min = null;\n        } else {\n          this._min = min.getRight();\n        }\n\n        this._rootList.forEach((node, index) => {\n          if (node.getVal() === min.getVal()) {\n            this._rootList.splice(index, 1);\n          }\n\n          return;\n        });\n      }\n\n      this.consolidate();\n      return min;\n    };\n\n    this.link = (node1, node2) => {\n      this._rootList.forEach((node, index) => {\n        if (node2.getVal() === node.getVal()) {\n          node1.setParent(node2.getParent());\n          node1.setLeft(node2.getLeft());\n          node1.setRight(node2.getRight());\n\n          this._rootList.splice(index, 1);\n\n          if (node1.getChild()) {\n            node1.getChild().push(node2);\n            const child1 = node1.getChild()[node1.getChild().length - 2];\n            const child2 = node1.getChild()[node1.getChild().length - 1];\n            child2.setRight(child1.getRight());\n            child1.getRight().setLeft(child2);\n            child1.setRight(child2);\n            child2.setLeft(child1.getChild());\n            child2.setParent(child1);\n          } else {\n            node1.setChild([node2]);\n            node2.setParent(node1);\n            node2.setRight(node2);\n            node2.setLeft(node2);\n          }\n\n          node1.incrementDegree();\n          node2.setIsMarked(false);\n        }\n\n        return;\n      });\n\n      return;\n    };\n\n    this.consolidate = () => {\n      const arr = [];\n\n      this._rootList.forEach(node => {\n        let node1 = node;\n        let degree = node1.getDegree(); //degree is being used as an index\n\n        while (arr[degree]) {\n          let node2 = arr[degree];\n\n          if (node1.getVal() > node2.getVal()) {\n            const tmpNode = node1;\n            node1 = node2;\n            node2 = tmpNode;\n          }\n\n          this.link(node1, node2);\n          degree += 1;\n        }\n\n        arr[degree] = node1;\n      });\n\n      this._rootList.forEach((node, index) => {\n        if (arr[index]) {\n          this._rootList.push(arr[index]);\n\n          const node1 = this._rootList[this._rootList - 2];\n          const node2 = this._rootList[this._rootList - 1];\n          node2.setRight(node1.getRight());\n          node1.getRight().setLeft(node2);\n          node1.setRight(node2);\n          node2.setLeft(node1);\n\n          if (this._min === null || arr[index].getVal() < this._min) {\n            this._min = arr[index];\n          }\n        }\n      });\n    };\n\n    this.union = h => {\n      this._min = h.peek();\n      const hStartIndex = this._rootList.length;\n      const hEndIndex = h.length - 1;\n      this._rootList = this._rootList.concat(h);\n\n      if (hStartIndex !== 0) {\n        const node1 = this._rootList[hStartIndex - 1];\n        const node2 = this._rootList[hStartIndex];\n        const node3 = this._rootList[hEndIndex];\n        node3.setRight(node1.getRight());\n        node1.getRight().setLeft(node3);\n        node1.setRight(node2);\n        node2.setLeft(node1);\n      }\n\n      if ((this._min === null || h.peek()) && h.peek() < this._min) {\n        this._min = h.peek();\n      } //clear h object\n\n    };\n\n    this.decreaseKey = (node, val) => {\n      if (val > node.getVal()) {\n        throw new Error(\"Replacement key is greater than the original key\");\n      }\n\n      node.setVal(val);\n      const parent = node.getParent();\n\n      if (parent !== null && node.getVal() < parent.getVal()) {\n        this.cut(node, parent);\n        this.cascadingCut(parent);\n      }\n    };\n\n    this.cut = (child, parent) => {\n      parent.getChild().forEach((node, index) => {\n        if (node.getValue() === child.getValue()) {\n          parent.getChild().splice(index, 1);\n          child.setParent(null);\n          child.setIsMarked(false);\n\n          this._rootList.push(child); //Understand better why the degree is being decremented here\n\n\n          parent.decrementDegree();\n        }\n\n        return;\n      });\n    };\n\n    this.cascadingCut = parent => {\n      const grandParent = parent.getParent();\n\n      if (grandParent !== null) {\n        if (parent.isMarked() === false) {\n          parent.setIsMarked(true);\n        } else {\n          this.cut(parent, grandParent);\n          this.cascadingCut(grandParent);\n        }\n      }\n    };\n\n    this._rootList = [];\n    this._min = null;\n  }\n\n}\n\nexport default FibonacciHeap;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Algorithms/FibonacciHeap.js"],"names":["FibonacciHeap","constructor","insert","node","_rootList","push","length","node1","node2","setRight","getRight","setLeft","_min","getVal","peek","extractMin","min","getChild","forEach","index","setParent","splice","consolidate","link","getParent","getLeft","child1","child2","setChild","incrementDegree","setIsMarked","arr","degree","getDegree","tmpNode","union","h","hStartIndex","hEndIndex","concat","node3","decreaseKey","val","Error","setVal","parent","cut","cascadingCut","child","getValue","decrementDegree","grandParent","isMarked"],"mappings":"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","sourcesContent":["class FibonacciHeap{\n    constructor(){\n        this._rootList = [];\n        this._min = null;\n    }\n\n    insert = (node) => {\n        this._rootList.push(node);\n\n        if(this._rootList.length > 1){\n            const node1 = this._rootList[this._rootList-2];\n            const node2 = this._rootList[this._rootList-1];\n            \n            node2.setRight(node1.getRight());\n            node1.getRight().setLeft(node2);\n            node1.setRight(node2);\n            node2.setLeft(node1);\n        }else{\n            const node1 = this._rootList[0];\n            node1.setRight(node1);\n            node1.setLeft(node1);\n        }\n\n        if(this._min < node.getVal()){\n            this._min = node;\n        }\n    }\n\n    peek = () => {\n        return this._min;\n    }\n\n    extractMin = () => {\n        const min = this._min;\n\n        if(min){\n            min.getChild().forEach((node, index) => {\n                node.setParent(null);\n\n                this.insert(node);\n            })\n\n            if(min === min.getRight()){\n                this._min = null;\n            }else{\n                this._min = min.getRight()\n            }\n\n            this._rootList.forEach((node, index) => {\n                if(node.getVal() === min.getVal()){\n                    this._rootList.splice(index, 1);\n                }\n                return;\n            })\n\n        }\n\n        this.consolidate();\n\n        return min;\n    }\n\n    link = (node1, node2) => {\n        this._rootList.forEach((node, index) => {\n            if(node2.getVal() === node.getVal()){\n                node1.setParent(node2.getParent());\n                node1.setLeft(node2.getLeft());\n                node1.setRight(node2.getRight());\n\n                this._rootList.splice(index, 1);\n\n                if(node1.getChild()){\n                    node1.getChild().push(node2);\n                    \n                    const child1 = node1.getChild()[node1.getChild().length-2];\n                    const child2 = node1.getChild()[node1.getChild().length-1];\n\n                    child2.setRight(child1.getRight());\n                    child1.getRight().setLeft(child2);\n                    child1.setRight(child2);\n                    child2.setLeft(child1.getChild());\n                    child2.setParent(child1);\n                }else{\n                    node1.setChild([node2]);\n                    node2.setParent(node1);\n                    node2.setRight(node2)\n                    node2.setLeft(node2);\n                }\n\n                node1.incrementDegree();\n                node2.setIsMarked(false);\n            }\n\n            return;\n        });\n\n        return;\n    }\n\n    consolidate = () => {\n        const arr = [];\n\n        this._rootList.forEach((node) => {\n            let node1 = node;\n            let degree = node1.getDegree();\n\n            //degree is being used as an index\n            while(arr[degree]){\n                let node2 = arr[degree];\n\n                if(node1.getVal() > node2.getVal()){\n                    const tmpNode = node1;\n\n                    node1 = node2;\n                    node2 = tmpNode;\n                }\n\n                this.link(node1, node2);\n\n                degree += 1;\n            }\n\n            arr[degree] = node1;\n        })\n\n        this._rootList.forEach((node, index) => {\n            if(arr[index]){\n                this._rootList.push(arr[index]);\n                \n                const node1 = this._rootList[this._rootList-2];\n                const node2 = this._rootList[this._rootList-1];\n\n                node2.setRight(node1.getRight());\n                node1.getRight().setLeft(node2);\n                node1.setRight(node2);\n                node2.setLeft(node1);\n\n                if(this._min === null || arr[index].getVal() < this._min){\n                    this._min = arr[index];\n                }\n            }\n        })\n    }\n\n    union = (h) => {   \n        this._min = h.peek();\n\n        const hStartIndex = this._rootList.length;\n        const hEndIndex = h.length-1;\n\n        this._rootList = this._rootList.concat(h);\n\n        if(hStartIndex !== 0){\n            const node1 = this._rootList[hStartIndex-1];\n            const node2 = this._rootList[hStartIndex];\n            const node3 = this._rootList[hEndIndex];\n\n            node3.setRight(node1.getRight())\n            node1.getRight().setLeft(node3)\n            node1.setRight(node2);\n            node2.setLeft(node1);\n        }\n\n        if((this._min === null || h.peek()) && h.peek() < this._min){\n            this._min = h.peek();\n        }\n\n        //clear h object\n    }\n\n    decreaseKey = (node, val) => {\n        if(val > node.getVal()){\n            throw new Error(\"Replacement key is greater than the original key\");\n        }\n\n        node.setVal(val);\n\n        const parent = node.getParent();\n\n        if(parent !== null && node.getVal() < parent.getVal()){\n            this.cut(node, parent);\n            this.cascadingCut(parent);\n        }\n    }\n    \n    cut = (child, parent) => {\n        parent.getChild().forEach((node, index) => {\n            if(node.getValue() === child.getValue()){\n                parent.getChild().splice(index, 1);\n\n                child.setParent(null);\n                child.setIsMarked(false);\n                this._rootList.push(child);\n\n                //Understand better why the degree is being decremented here\n                parent.decrementDegree();\n            }\n            return;\n        })\n    }\n\n    cascadingCut = (parent) => {\n        const grandParent = parent.getParent();\n\n        if(grandParent !== null){\n            if(parent.isMarked() === false){\n                parent.setIsMarked(true);\n            }else{\n                this.cut(parent, grandParent);\n                this.cascadingCut(grandParent);\n            }\n        }\n    }\n}\n\nexport default FibonacciHeap;\n\n"]},"metadata":{},"sourceType":"module"}