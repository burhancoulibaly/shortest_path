{"ast":null,"code":"var _jsxFileName = \"/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js\";\nimport React, { useState, useContext, useEffect, useMemo } from 'react';\nimport './Map.css';\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\n\nfunction Map(props) {\n  const [menuState, dispatch] = useContext(MenuContext);\n  const [state, setState] = useState({\n    rows: 15,\n    cols: 50,\n    grid: new Array(15 * 50).fill({\n      val: false,\n      type: null\n    }),\n    //space-time O(1)\n    itemState: menuState.itemState\n  });\n  const memoizedMenuState = useMemo(() => ({\n    menuState,\n    dispatch\n  }), [menuState, dispatch]);\n  console.log(memoizedMenuState);\n  const memoizedState = useMemo(() => ({\n    state,\n    setState\n  }), [state, setState]);\n  console.log(memoizedState); //If item button is changed\n\n  useEffect(() => {\n    memoizedState.setState(memoizedState => {\n      return { ...memoizedState.state,\n        itemState: memoizedMenuState.menuState.itemState\n      };\n    });\n  }, [memoizedMenuState.menuState.itemState]); //If menu clear button is clicked\n  // useEffect(() => {\n  //     if(memoizedMenuState.menuState.clear === true){\n  //         memoizedState.setState((memoizedState) => {\n  //             return {\n  //                 ...memoizedState.state,\n  //                 grid: new Array(memoizedState.state.rows*memoizedState.state.cols).fill({val: false, type: null})\n  //             }\n  //         })\n  //         return dispatch({type: \"cleared\"});\n  //     }\n  // }, [memoizedMenuState.menuState.clear, dispatch]);\n\n  useEffect(() => {\n    if (memoizedMenuState.menuState.run === true) {\n      //Visualize path finding algorithm logic\n      return dispatch({\n        type: \"complete\"\n      });\n    }\n  }, [memoizedMenuState.menuState.run, dispatch]);\n\n  const renderSquare = (x, y, val) => {\n    return /*#__PURE__*/React.createElement(Square //Minus 4 accounts for width and height\n    , {\n      width: memoizedState.state.cols > memoizedState.state.rows ? props.winDimensions.width / memoizedState.state.cols - 4 : props.winDimensions.width / memoizedState.state.cols * (Math.min(props.winDimensions.width / memoizedState.state.cols, props.winDimensions.height / memoizedState.state.rows) / Math.max(props.winDimensions.width / memoizedState.state.cols, props.winDimensions.height / memoizedState.state.rows)) - 4,\n      height: memoizedState.state.rows === memoizedState.state.cols ? props.winDimensions.height / memoizedState.state.rows - 4 //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n      : props.winDimensions.height / memoizedState.state.rows * (Math.min(props.winDimensions.width / memoizedState.state.cols, props.winDimensions.height / memoizedState.state.rows) / Math.max(props.winDimensions.width / memoizedState.state.cols, props.winDimensions.height / memoizedState.state.rows)) - 4,\n      x: x,\n      y: y,\n      val: val,\n      squareClick: (x, y) => handleClick(x, y),\n      itemState: memoizedState.state.itemState,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 54,\n        columnNumber: 13\n      }\n    });\n  };\n\n  const renderMap = () => {\n    //space-time O(1)\n    const rows = Array(memoizedState.state.rows); //each row will contain an array of 50 available indexes\n\n    const cols = Array(memoizedState.state.rows); //time O(n)\n\n    for (let i = 0; i < memoizedState.state.grid.length; i++) {\n      if (i % memoizedState.state.cols === 0) {\n        cols[i / memoizedState.state.cols] = Array(memoizedState.state.cols); //space-time O(1)\n\n        rows[i] = /*#__PURE__*/React.createElement(\"div\", {\n          className: \"grid-row\",\n          key: i / memoizedState.state.cols,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 88,\n            columnNumber: 21\n          }\n        }, cols[i / memoizedState.state.cols]);\n      }\n\n      let square = /*#__PURE__*/React.createElement(\"div\", {\n        className: \"grid-col\",\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 95,\n          columnNumber: 17\n        }\n      }, renderSquare(i % memoizedState.state.cols, Math.abs((i - i % memoizedState.state.cols) / memoizedState.state.cols), memoizedState.state.grid[i].val));\n      cols[(i - i % memoizedState.state.cols) / memoizedState.state.cols][i % memoizedState.state.cols] = square;\n    }\n\n    const map = rows;\n    return map;\n  };\n\n  const handleClick = (x, y) => {\n    switch (memoizedState.state.itemState) {\n      case \"start\":\n        memoizedState.setState(memoizedState => ({ ...memoizedState.state,\n          //state object is immutable so updates have to be done this way\n          grid: memoizedState.state.grid.map((square, index) => {\n            if (index === x + y * memoizedState.state.cols) {\n              // console.log(x,y,square.type,memoizedState.state.itemState);\n              if (square.type === memoizedState.state.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memoizedState.state.itemState\n                };\n              }\n            }\n\n            if (square.type === memoizedState.state.itemState && square.val && !memoizedState.state.grid[x + y * memoizedState.state.cols].val) {\n              return { ...square,\n                val: false\n              };\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"wall\":\n        memoizedState.setState(memoizedState => ({ ...memoizedState.state,\n          //state object is immutable so updates have to be done this way\n          grid: memoizedState.state.grid.map((square, index) => {\n            if (index === x + y * memoizedState.state.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memoizedState.state.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memoizedState.state.itemState\n                };\n              }\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"end\":\n        memoizedState.setState(memoizedState => ({ ...memoizedState.state,\n          //state object is immutable so updates have to be done this way\n          grid: memoizedState.state.grid.map((square, index) => {\n            if (index === x + y * memoizedState.state.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memoizedState.state.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memoizedState.state.itemState\n                };\n              }\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      default:\n        break;\n    }\n\n    return;\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    id: \"map\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 9\n    }\n  }, console.time(), renderMap(), console.timeEnd());\n}\n\nexport default Map;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js"],"names":["React","useState","useContext","useEffect","useMemo","Square","MenuContext","Map","props","menuState","dispatch","state","setState","rows","cols","grid","Array","fill","val","type","itemState","memoizedMenuState","console","log","memoizedState","run","renderSquare","x","y","winDimensions","width","Math","min","height","max","handleClick","renderMap","i","length","square","abs","map","index","time","timeEnd"],"mappings":"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","sourcesContent":["import React, { useState, useContext, useEffect, useMemo } from 'react';\nimport './Map.css';\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\n\nfunction Map(props) {\n    const [menuState, dispatch] = useContext(MenuContext);\n    const [state, setState] = useState({\n        rows: 15,\n        cols: 50,\n        grid: new Array(15*50).fill({val: false, type: null}),//space-time O(1)\n        itemState: menuState.itemState\n    })\n\n    const memoizedMenuState = useMemo(() => ({menuState, dispatch}), [menuState, dispatch]);\n    console.log(memoizedMenuState)\n    const memoizedState = useMemo(() => ({state, setState}), [state, setState])\n\n    console.log(memoizedState)\n    //If item button is changed\n    useEffect(() => {\n        memoizedState.setState((memoizedState) => {\n            return {\n                ...memoizedState.state,\n                itemState: memoizedMenuState.menuState.itemState\n            }\n        })\n    }, [memoizedMenuState.menuState.itemState]);\n\n    //If menu clear button is clicked\n    // useEffect(() => {\n    //     if(memoizedMenuState.menuState.clear === true){\n    //         memoizedState.setState((memoizedState) => {\n    //             return {\n    //                 ...memoizedState.state,\n    //                 grid: new Array(memoizedState.state.rows*memoizedState.state.cols).fill({val: false, type: null})\n    //             }\n    //         })\n\n    //         return dispatch({type: \"cleared\"});\n    //     }\n    // }, [memoizedMenuState.menuState.clear, dispatch]);\n\n    useEffect(() => {\n        if(memoizedMenuState.menuState.run === true){\n            //Visualize path finding algorithm logic\n\n            return dispatch({type: \"complete\"});\n        }\n    }, [memoizedMenuState.menuState.run, dispatch]);\n    \n    const renderSquare = (x,y,val) => {\n        return (\n            <Square\n                //Minus 4 accounts for width and height\n                width={\n                    memoizedState.state.cols > memoizedState.state.rows\n                        ? (props.winDimensions.width / memoizedState.state.cols) - 4\n                        : (props.winDimensions.width / memoizedState.state.cols) * (Math.min((props.winDimensions.width / memoizedState.state.cols),(props.winDimensions.height / memoizedState.state.rows)) / Math.max((props.winDimensions.width / memoizedState.state.cols),(props.winDimensions.height / memoizedState.state.rows))) - 4 \n                }\n                height={\n                    memoizedState.state.rows === memoizedState.state.cols\n                        ? (props.winDimensions.height / memoizedState.state.rows) - 4\n                        //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n                        : (props.winDimensions.height / memoizedState.state.rows) * (Math.min((props.winDimensions.width / memoizedState.state.cols),(props.winDimensions.height / memoizedState.state.rows)) / Math.max((props.winDimensions.width / memoizedState.state.cols),(props.winDimensions.height / memoizedState.state.rows))) - 4\n                }\n                x={x}\n                y={y}\n                val={val}\n                squareClick={(x, y) => handleClick(x, y)}\n                itemState={memoizedState.state.itemState}\n            />\n        )\n    }\n\n    const renderMap = () => {\n        //space-time O(1)\n        const rows = Array(memoizedState.state.rows);\n        //each row will contain an array of 50 available indexes\n        const cols = Array(memoizedState.state.rows);\n\n        //time O(n)\n        for(let i = 0; i < memoizedState.state.grid.length; i++){\n            if(i % memoizedState.state.cols === 0){\n                cols[i / memoizedState.state.cols] = Array(memoizedState.state.cols)//space-time O(1)\n\n                rows[i] = (\n                    <div className=\"grid-row\" key={i / memoizedState.state.cols}>\n                        {cols[i / memoizedState.state.cols]}\n                    </div>\n                )\n            }\n\n            let square = (\n                <div className=\"grid-col\" key={i}>\n                    {renderSquare(i % memoizedState.state.cols, Math.abs((i - (i % memoizedState.state.cols)) / memoizedState.state.cols), memoizedState.state.grid[i].val)}\n                </div>\n            )\n\n            cols[(i - (i % memoizedState.state.cols)) / memoizedState.state.cols][i % memoizedState.state.cols] = square;\n        }\n\n        const map = rows;\n\n        return map;\n    }\n\n    const handleClick = (x,y) => {\n        switch (memoizedState.state.itemState) {\n            case \"start\":\n                memoizedState.setState(memoizedState => ({\n                    ...memoizedState.state,\n                    //state object is immutable so updates have to be done this way\n                    grid: memoizedState.state.grid.map((square, index) => {\n                        if(index === x + (y * memoizedState.state.cols)){\n                            // console.log(x,y,square.type,memoizedState.state.itemState);\n                            if(square.type === memoizedState.state.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memoizedState.state.itemState}\n                            }\n                        }\n\n                        if(square.type === memoizedState.state.itemState && square.val && !memoizedState.state.grid[x + (y * memoizedState.state.cols)].val){\n                            return {...square, val: false}\n                        }\n\n                        return {...square}\n                    })\n                }));\n                \n                break;\n\n            case \"wall\":\n                memoizedState.setState(memoizedState => ({\n                    ...memoizedState.state,\n                    //state object is immutable so updates have to be done this way\n                    grid: memoizedState.state.grid.map((square, index) => {\n                        if(index === x + (y * memoizedState.state.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memoizedState.state.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memoizedState.state.itemState}\n                            }\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n\n            case \"end\":\n                memoizedState.setState(memoizedState => ({\n                    ...memoizedState.state,\n                    //state object is immutable so updates have to be done this way\n                    grid: memoizedState.state.grid.map((square, index) => {\n                        if(index === x + (y * memoizedState.state.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memoizedState.state.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memoizedState.state.itemState}\n                            }\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n        \n            default:\n                break;\n        }\n\n        return;\n    }\n    \n\n\n    return (\n        <div id=\"map\">\n            {console.time()}\n                {renderMap()}\n            {console.timeEnd()}\n        </div>\n    )\n}\n\nexport default Map;"]},"metadata":{},"sourceType":"module"}