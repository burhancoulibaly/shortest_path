{"ast":null,"code":"class FibonacciHeap {\n  constructor() {\n    this.getRootList = () => {\n      return this._rootList;\n    };\n\n    this.insert = node => {\n      node.setParent(null);\n\n      this._rootList.push(node);\n\n      if (this._rootList.length > 1) {\n        const node1 = this._rootList[this._rootList.length - 2];\n        const node2 = this._rootList[this._rootList.length - 1];\n        node2.setRight(node1.getRight());\n        node1.getRight().setLeft(node2);\n        node1.setRight(node2);\n        node2.setLeft(node1);\n      } else {\n        const node1 = this._rootList[this._rootList.length - 1];\n        node1.setRight(node1);\n        node1.setLeft(node1);\n      }\n\n      if (this._min === null || node.getVal() < this._min.getVal()) {\n        this._min = node;\n      }\n    };\n\n    this.peek = () => {\n      return this._min;\n    };\n\n    this.extractMin = () => {\n      const min = this._min;\n\n      if (min) {\n        if (min.getChild()) {\n          min.getChild().forEach(node => {\n            node.setParent(null);\n            this.insert(node);\n          });\n          console.log(Array.from(this._rootList));\n        }\n\n        if (min === min.getRight()) {\n          this._min = null;\n        } else {\n          this._min = min.getRight();\n        }\n\n        this._rootList.forEach((node, index) => {\n          if (node === min) {\n            this._rootList.splice(index, 1);\n          }\n\n          return;\n        });\n      }\n\n      this.consolidate();\n      return min;\n    };\n\n    this.link = (node1, node2) => {\n      this._rootList.forEach((node, index) => {\n        if (node2 === node) {\n          node1.setParent(null);\n          node1.setLeft(null);\n          node1.setRight(null);\n\n          if (node1.getChild() === null) {\n            node1.setChild([]);\n          }\n\n          node1.getChild().push(node2);\n\n          if (node1.getChild().length > 1) {\n            const child1 = node1.getChild()[node1.getChild().length - 2];\n            const child2 = node1.getChild()[node1.getChild().length - 1];\n\n            if (child1._point.x === 49 && child1._point.y === 14) {\n              console.log(Object.assign({}, child1));\n            }\n\n            if (child2._point.x === 49 && child2._point.y === 14) {\n              console.log(Object.assign({}, child2));\n            }\n\n            child2.setRight(child1.getRight());\n            child1.getRight().setLeft(child2);\n            child1.setRight(child2);\n            child2.setLeft(child1);\n            child2.setParent(child1.getParent());\n            child2.setIsMarked(false);\n          } else {\n            const child1 = node1.getChild()[node1.getChild().length - 1];\n\n            if (child1._point.x === 49 && child1._point.y === 14) {\n              console.log(Object.assign({}, child1));\n            }\n\n            child1.setRight(child1);\n            child1.setLeft(child1);\n            child1.setParent(node1);\n            child1.setIsMarked(false);\n          }\n\n          node1.incrementDegree();\n        }\n\n        return null;\n      });\n\n      return node1;\n    };\n\n    this.consolidate = () => {\n      const arr = new Array(parseInt(this._rootList.length / Math.log(2)));\n\n      this._rootList.forEach((node, index) => {\n        let node1 = node;\n        if (node1.point.x == 49) console.log(node1);\n        let degree = node1.getDegree(); //degree is being used as an index\n\n        while (arr[degree]) {\n          let node2 = arr[degree];\n\n          if (node1.getVal() > node2.getVal()) {\n            const tmpNode = node1;\n            node1 = node2;\n            node2 = tmpNode;\n          }\n\n          if (node1 === node2) {\n            console.log(node1, node2);\n          }\n\n          if (node1 !== node2) {\n            console.log(node1, node2);\n            node1 = this.link(node1, node2);\n          }\n\n          arr[degree] = undefined;\n          degree += 1;\n        }\n\n        arr[degree] = node1;\n      });\n\n      this._rootList = [];\n      arr.forEach((node, index) => {\n        if (node) {\n          this.insert(node);\n\n          if (this._min === null || arr[index].getVal() < this._min.getVal()) {\n            this._min = arr[index];\n          }\n        }\n      });\n    };\n\n    this.union = h => {\n      this._min = h.peek();\n      const hStartIndex = this._rootList.length;\n      const hEndIndex = h.length - 1;\n      this._rootList = this._rootList.concat(h);\n\n      if (hStartIndex !== 0) {\n        const node1 = this._rootList[hStartIndex - 1];\n        const node2 = this._rootList[hStartIndex];\n        const node3 = this._rootList[hEndIndex];\n        node3.setRight(node1.getRight());\n        node1.getRight().setLeft(node3);\n        node1.setRight(node2);\n        node2.setLeft(node1);\n      }\n\n      if ((this._min === null || h.peek()) && h.peek() < this._min) {\n        this._min = h.peek();\n      } //clear h object\n\n    };\n\n    this.decreaseKey = (node, val) => {\n      if (val > node.getVal()) {\n        throw new Error(\"Replacement key is greater than the original key\");\n      }\n\n      node.setVal(val);\n      const parent = node.getParent();\n\n      if (parent !== null && node.getVal() < parent.getVal()) {\n        this.cut(node, parent);\n        this.cascadingCut(parent);\n      }\n    };\n\n    this.cut = (child, parent) => {\n      parent.getChild().forEach((node, index) => {\n        if (node === child) {\n          node.getLeft().setRight(node.getRight());\n          node.getRight().setLeft(node.getLeft());\n          parent.getChild().splice(index, 1);\n\n          if (parent.getChild().length === 0) {\n            parent.setChild(null);\n          }\n\n          node.setParent(null);\n          node.setLeft(null);\n          node.setRight(null);\n          node.setIsMarked(false);\n          this.insert(node); //Understand better why the degree is being decremented here\n\n          parent.decrementDegree();\n        }\n\n        return;\n      });\n    };\n\n    this.cascadingCut = parent => {\n      const grandParent = parent.getParent();\n\n      if (grandParent !== null) {\n        if (parent.isMarked() === false) {\n          parent.setIsMarked(true);\n        } else {\n          this.cut(parent, grandParent);\n          this.cascadingCut(grandParent);\n        }\n      }\n    };\n\n    this._rootList = [];\n    this._min = null;\n  } //Good\n\n\n}\n\nexport default FibonacciHeap;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Algorithms/FibonacciHeap.js"],"names":["FibonacciHeap","constructor","getRootList","_rootList","insert","node","setParent","push","length","node1","node2","setRight","getRight","setLeft","_min","getVal","peek","extractMin","min","getChild","forEach","console","log","Array","from","index","splice","consolidate","link","setChild","child1","child2","_point","x","y","Object","assign","getParent","setIsMarked","incrementDegree","arr","parseInt","Math","point","degree","getDegree","tmpNode","undefined","union","h","hStartIndex","hEndIndex","concat","node3","decreaseKey","val","Error","setVal","parent","cut","cascadingCut","child","getLeft","decrementDegree","grandParent","isMarked"],"mappings":"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","sourcesContent":["class FibonacciHeap{\n    constructor(){\n        this._rootList = [];\n        this._min = null;\n    }\n\n    //Good\n    getRootList = () => {\n        return this._rootList;\n    }\n\n    //Good\n    insert = (node) => {\n        node.setParent(null);\n\n        this._rootList.push(node);\n\n        if(this._rootList.length > 1){\n            const node1 = this._rootList[this._rootList.length-2];\n            const node2 = this._rootList[this._rootList.length-1];\n            \n            node2.setRight(node1.getRight());\n            node1.getRight().setLeft(node2);\n            node1.setRight(node2);\n            node2.setLeft(node1);\n        }else{\n            const node1 = this._rootList[this._rootList.length-1];\n            node1.setRight(node1);\n            node1.setLeft(node1);\n        }\n        \n        if(this._min === null || node.getVal() < this._min.getVal()){\n            this._min = node;\n        }\n    }\n\n    //Good\n    peek = () => {\n        return this._min;\n    }\n\n    //Good\n    extractMin = () => {\n        const min = this._min;\n\n        if(min){\n            if(min.getChild()){\n                min.getChild().forEach((node) => {\n                    node.setParent(null);\n    \n                    this.insert(node);\n                })\n\n                console.log(Array.from(this._rootList));\n            }\n\n            if(min === min.getRight()){\n                this._min = null;\n            }else{\n                this._min = min.getRight()\n            }\n\n            this._rootList.forEach((node, index) => {\n                if(node === min){\n                    this._rootList.splice(index, 1);\n                }\n                return;\n            })\n\n        }\n\n        this.consolidate();\n\n        return min;\n    }\n\n    //Good\n    link = (node1, node2) => {\n        this._rootList.forEach((node, index) => {\n            if(node2 === node){\n                node1.setParent(null);\n                node1.setLeft(null);\n                node1.setRight(null);\n                \n                if(node1.getChild() === null){\n                    node1.setChild([]);\n                }\n\n                node1.getChild().push(node2);\n                \n                if(node1.getChild().length > 1){\n                    const child1 = node1.getChild()[node1.getChild().length-2];\n                    const child2 = node1.getChild()[node1.getChild().length-1];\n\n                    if(child1._point.x === 49 && child1._point.y === 14){\n                        console.log(Object.assign({},child1));\n                    }\n                    if(child2._point.x === 49 && child2._point.y === 14){\n                        console.log(Object.assign({},child2));\n                    }\n\n                    child2.setRight(child1.getRight());\n                    child1.getRight().setLeft(child2);\n                    child1.setRight(child2);\n                    child2.setLeft(child1);\n                    child2.setParent(child1.getParent());\n\n                    child2.setIsMarked(false);\n                }else{\n                    const child1 = node1.getChild()[node1.getChild().length-1];\n\n                    if(child1._point.x === 49 && child1._point.y === 14){\n                        console.log(Object.assign({},child1));\n                    }\n                    \n                    child1.setRight(child1);\n                    child1.setLeft(child1);\n                    child1.setParent(node1);\n\n                    child1.setIsMarked(false);\n                }\n\n                node1.incrementDegree();\n            }\n\n            return null;\n        });\n\n        return node1;\n    }\n\n    //Good\n    consolidate = () => {\n        const arr = new Array(parseInt(this._rootList.length / Math.log(2)));\n        \n        this._rootList.forEach((node, index) => {\n            let node1 = node;\n\n            if(node1.point.x == 49)\n            console.log(node1);\n            let degree = node1.getDegree();\n\n            //degree is being used as an index\n            while(arr[degree]){\n                let node2 = arr[degree];\n\n                if(node1.getVal() > node2.getVal()){\n                    const tmpNode = node1;\n\n                    node1 = node2;\n                    node2 = tmpNode;\n                }\n\n                if(node1 === node2){\n                    console.log(node1, node2)\n                }\n\n                if(node1 !== node2){\n                    console.log(node1, node2)\n                    node1 = this.link(node1, node2);\n                }\n\n                arr[degree] = undefined;\n\n                degree += 1;\n            }\n            \n            arr[degree] = node1;\n        })\n\n        this._rootList = [];\n\n        arr.forEach((node, index) => {\n            if(node){\n                this.insert(node);\n\n                if(this._min === null || arr[index].getVal() < this._min.getVal()){\n                    this._min = arr[index];\n                }\n            }\n        })\n    }\n\n    //To be seen\n    union = (h) => {   \n        this._min = h.peek();\n\n        const hStartIndex = this._rootList.length;\n        const hEndIndex = h.length-1;\n\n        this._rootList = this._rootList.concat(h);\n\n        if(hStartIndex !== 0){\n            const node1 = this._rootList[hStartIndex-1];\n            const node2 = this._rootList[hStartIndex];\n            const node3 = this._rootList[hEndIndex];\n\n            node3.setRight(node1.getRight())\n            node1.getRight().setLeft(node3)\n            node1.setRight(node2);\n            node2.setLeft(node1);\n        }\n\n        if((this._min === null || h.peek()) && h.peek() < this._min){\n            this._min = h.peek();\n        }\n\n        //clear h object\n    }\n\n    //Good\n    decreaseKey = (node, val) => {\n        if(val > node.getVal()){\n            throw new Error(\"Replacement key is greater than the original key\");\n        }\n\n        node.setVal(val);\n\n        const parent = node.getParent();\n\n        if(parent !== null && node.getVal() < parent.getVal()){\n            this.cut(node, parent);\n            this.cascadingCut(parent);\n        }\n    }\n    \n    //Good\n    cut = (child, parent) => {\n        parent.getChild().forEach((node, index) => {\n            if(node === child){\n                node.getLeft().setRight(node.getRight());\n                node.getRight().setLeft(node.getLeft());\n\n                parent.getChild().splice(index, 1);   \n\n                if(parent.getChild().length === 0){\n                    parent.setChild(null);\n                }\n\n                node.setParent(null);\n                node.setLeft(null);\n                node.setRight(null);\n                node.setIsMarked(false);\n\n                this.insert(node);\n\n                //Understand better why the degree is being decremented here\n                parent.decrementDegree();\n            }\n            return;\n        })\n    }\n\n    //Good\n    cascadingCut = (parent) => {\n        const grandParent = parent.getParent();\n\n        if(grandParent !== null){\n            if(parent.isMarked() === false){\n                parent.setIsMarked(true);\n            }else{\n                this.cut(parent, grandParent);\n                this.cascadingCut(grandParent);\n            }\n        }\n    }\n}\n\nexport default FibonacciHeap;\n\n"]},"metadata":{},"sourceType":"module"}