{"ast":null,"code":"var _jsxFileName = \"/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js\";\nimport React, { useState, useContext, useEffect, useMemo, useCallback } from 'react';\nimport UserContext from \"../UserContext\";\nimport { useLazyQuery, useMutation } from '@apollo/client';\nimport MapHelper from '../Helpers/MapHelper';\nimport './Map.css';\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\nimport AStar from '../Algorithms/AStar';\nimport AStarBiDirectional from '../Algorithms/Bi-Directional/AStar';\nimport Dijkstra from '../Algorithms/Dijkstra';\nimport DijkstraBiDirectional from '../Algorithms/Bi-Directional/Dijkstra';\nimport BFS from '../Algorithms/BFS';\nimport BFSBiDirectional from '../Algorithms/Bi-Directional/BFS';\nimport DFS from '../Algorithms/DFS';\nimport GreedyBFS from '../Algorithms/GreedyBFS';\nimport GreedyBFSBiDirectional from '../Algorithms/Bi-Directional/GreedyBFS';\n\nfunction Map(props) {\n  const {\n    user\n  } = useContext(UserContext);\n  const {\n    menuState,\n    dispatch\n  } = useContext(MenuContext);\n  const [state, setState] = useState({\n    rows: 15,\n    cols: 50,\n    grid: new Array(15 * 50).fill({\n      val: false,\n      type: null\n    }).map((square, i) => {\n      return { ...square,\n        x: i % 50,\n        y: Math.abs((i - i % 50) / 50)\n      };\n    }),\n    //space-time O(1)\n    itemState: menuState.itemState,\n    map: props.location ? props.location.state.userMap : null\n  });\n  const [saveMap, {\n    error: saveMapError,\n    data: saveMapData\n  }] = useMutation(MapHelper.saveMap, {\n    fetchPolicy: \"network-only\"\n  });\n  const {\n    state: memState\n  } = useMemo(() => ({\n    state\n  }), [state]); //If item button is changed\n\n  useEffect(() => {\n    setState(memState => {\n      return { ...memState,\n        itemState: menuState.itemState\n      };\n    });\n  }, [menuState.itemState]);\n  useEffect(() => {\n    if (menuState.isResetting === true) {\n      if (state.userMap) {\n        setState(memState => ({ ...memState,\n          grid: state.userMap\n        }));\n        return dispatch({\n          type: \"reset\"\n        });\n      }\n\n      setState(memState => ({ ...memState,\n        grid: new Array(15 * 50).fill({\n          val: false,\n          type: null\n        }).map((square, i) => {\n          return { ...square,\n            x: i % 50,\n            y: Math.abs((i - i % 50) / 50)\n          };\n        })\n      }));\n      return dispatch({\n        type: \"reset\"\n      });\n    }\n  }, [menuState.isResetting, state.userMap, dispatch]); //If menu clear button is clicked\n\n  useEffect(() => {\n    if (menuState.clear === true) {\n      setState(memState => ({ ...memState,\n        grid: memState.grid.map((square, index) => {\n          if (square.type !== \"start\" && square.type !== \"end\") {\n            return { ...square,\n              val: false,\n              type: null\n            };\n          }\n\n          return { ...square\n          };\n        })\n      }));\n      return dispatch({\n        type: \"cleared\"\n      });\n    }\n  }, [menuState.clear, dispatch]); //If menu clear path button is clicked\n\n  useEffect(() => {\n    if (menuState.pathClear === true) {\n      setState(memState => ({ ...memState,\n        grid: memState.grid.map((square, index) => {\n          if (square.type !== \"start\" && square.type !== \"end\" && square.type !== \"wall\") {\n            return { ...square,\n              val: false,\n              type: null\n            };\n          }\n\n          return { ...square\n          };\n        })\n      }));\n      return dispatch({\n        type: \"pathCleared\"\n      });\n    }\n  }, [menuState.pathClear, dispatch]);\n  useEffect(() => {\n    if (menuState.isSaving) {\n      //saving map\n      saveMap({\n        variables: {\n          username: user.username,\n          map: state.grid\n        }\n      });\n    }\n  }, [menuState.isSaving, state.grid, saveMapError, saveMapData, dispatch]);\n  useEffect(() => {\n    if (menuState.isSaving) {\n      if (saveMapError) {\n        return console.log(saveMapError);\n      }\n\n      if (saveMapData) {\n        return console.log(saveMapData);\n      }\n\n      return dispatch({\n        type: \"save\"\n      });\n    }\n  }, [saveMapError, saveMapData, dispatch]);\n  const drawPath = useCallback(newState => {\n    setTimeout(() => {\n      if (menuState.run) {\n        setState({ ...newState,\n          //newState object is immutable so updates have to be done this way\n          grid: newState.grid\n        });\n      }\n    }, 4);\n  }, [menuState.run]); //If run menu button is clicked\n\n  useEffect(() => {\n    if (menuState.run === true) {\n      let states = null; // Visualize path finding algorithm logic\n      // console.time()\n\n      if (menuState.biDirectional === true) {\n        switch (menuState.algorithm) {\n          case \"astar\":\n            states = AStarBiDirectional(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"dijkstra\":\n            states = DijkstraBiDirectional(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"bfs\":\n            states = BFSBiDirectional(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"dfs\":\n            states = DFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"greedybfs\":\n            states = GreedyBFSBiDirectional(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          default:\n            console.log(\"Must choose a path finding algorithm\");\n            break;\n        }\n      } else {\n        switch (menuState.algorithm) {\n          case \"astar\":\n            states = AStar(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"dijkstra\":\n            states = Dijkstra(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"bfs\":\n            states = BFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"dfs\":\n            states = DFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          case \"greedybfs\":\n            states = GreedyBFS(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n            break;\n\n          default:\n            console.log(\"Must choose a path finding algorithm\");\n            break;\n        }\n      } // console.timeEnd()\n\n\n      states.filter((newState, index) => {\n        if (index % 20 === 0) {\n          return newState;\n        }\n\n        if (index === states.length - 1) {\n          return newState;\n        }\n\n        return null;\n      }).map(newState => {\n        drawPath(newState);\n        return null;\n      });\n      return dispatch({\n        type: \"complete\"\n      });\n    }\n  }, [menuState.run, menuState.heuristic, menuState.cutCorners, menuState.allowDiags, menuState.algorithm, menuState.biDirectional, memState.grid, memState.rows, memState.cols, memState, drawPath, dispatch]);\n\n  const renderSquare = (x, y, val) => {\n    return /*#__PURE__*/React.createElement(Square //Minus 4 accounts for width and height\n    , {\n      width: memState.cols > memState.rows ? props.winDimensions.width / memState.cols - 4 : props.winDimensions.width / memState.cols * (Math.min(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows) / Math.max(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows)) - 4,\n      height: memState.rows === memState.cols ? props.winDimensions.height / memState.rows - 4 //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n      : props.winDimensions.height / memState.rows * (Math.min(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows) / Math.max(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows)) - 4,\n      x: x,\n      y: y,\n      val: val,\n      squareClick: (x, y) => handleClick(x, y),\n      type: memState.grid[x + y * memState.cols].type,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 13\n      }\n    });\n  };\n\n  const renderMap = () => {\n    //TODO: use x y variables set per index for this instead\n    //space-time O(1)\n    const rows = Array(memState.rows); //each row will contain an array of 50 available indexes\n\n    const cols = Array(memState.rows); //time O(n)\n\n    for (let i = 0; i < memState.grid.length; i++) {\n      if (i % memState.cols === 0) {\n        cols[i / memState.cols] = Array(memState.cols); //space-time O(1)\n\n        rows[i] = /*#__PURE__*/React.createElement(\"div\", {\n          className: \"grid-row\",\n          key: i / memState.cols,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 272,\n            columnNumber: 21\n          }\n        }, cols[i / memState.cols]);\n      }\n\n      let square = /*#__PURE__*/React.createElement(\"div\", {\n        className: \"grid-col\",\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 279,\n          columnNumber: 17\n        }\n      }, renderSquare(i % memState.cols, Math.abs((i - i % memState.cols) / memState.cols), memState.grid[i].val));\n      cols[(i - i % memState.cols) / memState.cols][i % memState.cols] = square;\n    }\n\n    const map = rows;\n    return map;\n  };\n\n  const handleClick = (x, y) => {\n    switch (memState.itemState) {\n      case \"start\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,memState.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            if (square.type === memState.itemState && square.val && !memState.grid[x + y * memState.cols].val) {\n              return { ...square,\n                val: false,\n                type: null\n              };\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"wall\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"end\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            if (square.type === memState.itemState && square.val && !memState.grid[x + y * memState.cols].val) {\n              return { ...square,\n                val: false,\n                type: null\n              };\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      default:\n        break;\n    }\n\n    return;\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    id: \"map\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 372,\n      columnNumber: 9\n    }\n  }, renderMap());\n}\n\nexport default Map;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js"],"names":["React","useState","useContext","useEffect","useMemo","useCallback","UserContext","useLazyQuery","useMutation","MapHelper","Square","MenuContext","AStar","AStarBiDirectional","Dijkstra","DijkstraBiDirectional","BFS","BFSBiDirectional","DFS","GreedyBFS","GreedyBFSBiDirectional","Map","props","user","menuState","dispatch","state","setState","rows","cols","grid","Array","fill","val","type","map","square","i","x","y","Math","abs","itemState","location","userMap","saveMap","error","saveMapError","data","saveMapData","fetchPolicy","memState","isResetting","clear","index","pathClear","isSaving","variables","username","console","log","drawPath","newState","setTimeout","run","states","biDirectional","algorithm","heuristic","cutCorners","allowDiags","filter","length","renderSquare","winDimensions","width","min","height","max","handleClick","renderMap"],"mappings":"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","sourcesContent":["import React, { useState, useContext, useEffect, useMemo, useCallback } from 'react';\nimport UserContext from \"../UserContext\";\nimport { useLazyQuery, useMutation } from '@apollo/client';\nimport MapHelper from '../Helpers/MapHelper';\nimport './Map.css';\n\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\nimport AStar from '../Algorithms/AStar';\nimport AStarBiDirectional from '../Algorithms/Bi-Directional/AStar';\nimport Dijkstra from '../Algorithms/Dijkstra';\nimport DijkstraBiDirectional from '../Algorithms/Bi-Directional/Dijkstra';\nimport BFS from '../Algorithms/BFS';\nimport BFSBiDirectional from '../Algorithms/Bi-Directional/BFS';\nimport DFS from '../Algorithms/DFS';\nimport GreedyBFS from '../Algorithms/GreedyBFS';\nimport GreedyBFSBiDirectional from '../Algorithms/Bi-Directional/GreedyBFS';\n\n\nfunction Map(props) {\n    const {user} = useContext(UserContext);\n    const {menuState, dispatch} = useContext(MenuContext);\n    const [state, setState] = useState({\n        rows: 15,\n        cols: 50,\n        grid: new Array(15*50).fill({val: false, type: null}).map((square, i) => {\n            return {\n                ...square,\n                x: i % 50,\n                y: Math.abs((i - (i % 50)) / 50)\n            }\n        }),//space-time O(1)\n        itemState: menuState.itemState,\n        map: props.location ? props.location.state.userMap : null\n    })\n    const [saveMap, { error: saveMapError, data: saveMapData }] = useMutation(MapHelper.saveMap, { fetchPolicy: \"network-only\" });\n\n    const { state: memState } = useMemo(() => ({state}), [state])\n\n    //If item button is changed\n    useEffect(() => {\n        setState((memState) => {\n            return {\n                ...memState,\n                itemState: menuState.itemState\n            }\n        })\n    }, [menuState.itemState]);\n\n    useEffect(() => {\n        if(menuState.isResetting === true){\n            if(state.userMap){\n                setState((memState) => ({\n                    ...memState,\n                    grid: state.userMap\n                }))\n                return dispatch({type: \"reset\"});\n            }\n\n            setState((memState) => ({\n                ...memState,\n                grid: new Array(15*50).fill({val: false, type: null}).map((square, i) => {\n                    return {\n                        ...square,\n                        x: i % 50,\n                        y: Math.abs((i - (i % 50)) / 50)\n                    }\n                })\n            }))\n            return dispatch({type: \"reset\"});\n        }\n    }, [menuState.isResetting, state.userMap, dispatch]);\n\n    //If menu clear button is clicked\n    useEffect(() => {\n        if(menuState.clear === true){\n            setState((memState) => ({\n                ...memState,\n                grid: memState.grid.map((square, index) => {\n                    if(square.type !== \"start\" && square.type !== \"end\"){\n                        return {...square, val: false, type: null}\n                    }\n            \n                    return {...square}\n                })\n            }))\n            return dispatch({type: \"cleared\"});\n        }\n    }, [menuState.clear, dispatch]);\n\n    //If menu clear path button is clicked\n    useEffect(() => {\n        if(menuState.pathClear === true){\n            setState((memState) => ({\n                ...memState,\n                grid: memState.grid.map((square, index) => {\n                    if(square.type !== \"start\" && square.type !== \"end\" && square.type !== \"wall\"){\n                        return {...square, val: false, type: null}\n                    }\n            \n                    return {...square}\n                })\n            }))\n            return dispatch({type: \"pathCleared\"});\n        }\n    }, [menuState.pathClear, dispatch]);\n\n    useEffect(() => {\n        if(menuState.isSaving){\n            //saving map\n            saveMap({\n                  variables: {\n                    username: user.username,\n                    map: state.grid\n                }\n            })\n        }\n        \n    }, [menuState.isSaving, state.grid, saveMapError, saveMapData, dispatch])\n\n    useEffect(() => {\n        if(menuState.isSaving){\n            if(saveMapError){\n                return console.log(saveMapError);\n            }\n            \n            if(saveMapData){\n                return console.log(saveMapData)\n            }\n\n            return dispatch({type: \"save\"});\n        }\n        \n    }, [saveMapError, saveMapData, dispatch])\n    \n    const drawPath = useCallback((newState) => {\n        setTimeout(() => {\n            if(menuState.run){\n                setState({\n                    ...newState,\n                    //newState object is immutable so updates have to be done this way\n                    grid: newState.grid\n                }); \n            }\n        }, 4)\n    },[menuState.run])\n\n    //If run menu button is clicked\n    useEffect(() => {\n        if(menuState.run === true){\n            let states = null;\n\n            // Visualize path finding algorithm logic\n            // console.time()\n            if(menuState.biDirectional === true){\n                switch (menuState.algorithm) {\n                    case \"astar\":\n                        states = AStarBiDirectional(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"dijkstra\":\n                        states = DijkstraBiDirectional(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"bfs\":\n                        states = BFSBiDirectional(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"dfs\":\n                        states = DFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"greedybfs\":\n                        states = GreedyBFSBiDirectional(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    default:\n                        console.log(\"Must choose a path finding algorithm\")\n                        break;\n                }\n            }else{\n                switch (menuState.algorithm) {\n                    case \"astar\":\n                        states = AStar(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"dijkstra\":\n                        states = Dijkstra(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"bfs\":\n                        states = BFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"dfs\":\n                        states = DFS(memState.rows, memState.cols, memState.grid, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    case \"greedybfs\":\n                        states = GreedyBFS(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState, menuState.cutCorners, menuState.allowDiags);\n    \n                        break;\n                    default:\n                        console.log(\"Must choose a path finding algorithm\")\n                        break;\n                }\n            }\n            \n            // console.timeEnd()\n            \n            states\n            .filter((newState, index) => {\n                if(index % 20 === 0){\n                    return newState;\n                }\n\n                if(index === states.length-1){\n                    return newState;\n                }\n\n                return null;\n                \n            })\n            .map((newState) => {\n                drawPath(newState);\n\n                return null\n            })\n\n            return dispatch({type: \"complete\"});\n        }\n    }, [menuState.run, menuState.heuristic, menuState.cutCorners, menuState.allowDiags, menuState.algorithm, menuState.biDirectional, memState.grid, memState.rows, memState.cols, memState, drawPath, dispatch]);\n\n    \n    const renderSquare = (x,y,val) => {\n        return (\n            <Square\n                //Minus 4 accounts for width and height\n                width={\n                    memState.cols > memState.rows\n                        ? (props.winDimensions.width / memState.cols) - 4\n                        : (props.winDimensions.width / memState.cols) * (Math.min((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows)) / Math.max((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows))) - 4 \n                }\n                height={\n                    memState.rows === memState.cols\n                        ? (props.winDimensions.height / memState.rows) - 4\n                        //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n                        : (props.winDimensions.height / memState.rows) * (Math.min((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows)) / Math.max((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows))) - 4\n                }\n                x={x}\n                y={y}\n                val={val}\n                squareClick={(x, y) => handleClick(x, y)}\n                type={memState.grid[x + (y * memState.cols)].type}\n            />\n        )\n    }\n\n    const renderMap = () => {\n        //TODO: use x y variables set per index for this instead\n        //space-time O(1)\n        const rows = Array(memState.rows);\n        //each row will contain an array of 50 available indexes\n        const cols = Array(memState.rows);\n\n        //time O(n)\n        for(let i = 0; i < memState.grid.length; i++){\n            if(i % memState.cols === 0){\n                cols[i / memState.cols] = Array(memState.cols)//space-time O(1)\n\n                rows[i] = (\n                    <div className=\"grid-row\" key={i / memState.cols}>\n                        {cols[i / memState.cols]}\n                    </div>\n                )\n            }\n\n            let square = (\n                <div className=\"grid-col\" key={i}>\n                    {renderSquare(i % memState.cols, Math.abs((i - (i % memState.cols)) / memState.cols), memState.grid[i].val)}\n                </div>\n            )\n\n            cols[(i - (i % memState.cols)) / memState.cols][i % memState.cols] = square;\n        }\n\n        const map = rows;\n\n        return map;\n    }\n\n    const handleClick = (x,y) => {\n        switch (memState.itemState) {\n            case \"start\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,memState.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        if(square.type === memState.itemState && square.val && !memState.grid[x + (y * memState.cols)].val){\n                            return {...square, val: false, type: null}\n                        }\n\n                        return {...square}\n                    })\n                }));\n                \n                break;\n\n            case \"wall\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n\n            case \"end\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        if(square.type === memState.itemState && square.val && !memState.grid[x + (y * memState.cols)].val){\n                            return {...square, val: false, type: null}\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n        \n            default:\n                break;\n        }\n\n        return;\n    }\n    \n\n\n    return (\n        <div id=\"map\">\n            {/* {console.time()} */}\n                {renderMap()}\n            {/* {console.timeEnd()} */}\n        </div>\n    )\n}\n\nexport default Map;"]},"metadata":{},"sourceType":"module"}