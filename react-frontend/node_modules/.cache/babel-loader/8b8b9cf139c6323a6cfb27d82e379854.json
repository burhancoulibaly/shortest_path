{"ast":null,"code":"import FibonacciHeapNode from '../Algorithms/FibonacciHeapNode';\nconst Node = FibonacciHeapNode;\n\nfunction getIndex(x, y, cols) {\n  return x + y * cols;\n}\n\nfunction getNeighbors(current, rows, cols, node) {\n  //Point                                 Index\n  // left point.x-1, point.y              (point.x-1) + (point.y * cols)\n  // right point.x+1, point.y             (point.x+1) + (point.y * cols)\n  // up point.x, point.y-1                (point.x) + (point.y-1 * cols)\n  // down point.x, point.y+1              (point.x) + (point.y+1 * cols)\n  // top left point.x-1, point.y-1        (point.x-1) + (point.y-1 * cols)\n  // top right point.x+1, point.y-1       (point.x+1) + (point.y-1 * cols)\n  // bottom left point.x-1, point.y+1     (point.x-1) + (point.y+1 * cols)\n  // bottom right point.x+1, point.y+1    (point.x+1) + (point.y+1 * cols)\n  const neighbors = new Array(8);\n\n  if (current.getPoint().x > 0) {\n    const left = getIndex(current.getPoint().x - 1, current.getPoint().y, cols);\n\n    if (node[left].node.getPoint().type !== \"wall\") {\n      neighbors[0] = node[left].node;\n    }\n  }\n\n  if (current.getPoint().x < cols - 1) {\n    const right = getIndex(current.getPoint().x + 1, current.getPoint().y, cols);\n\n    if (node[right].node.getPoint().type !== \"wall\") {\n      neighbors[1] = node[right].node;\n    }\n  }\n\n  if (current.getPoint().y > 0) {\n    const up = getIndex(current.getPoint().x, current.getPoint().y - 1, cols);\n\n    if (node[up].node.getPoint().type !== \"wall\") {\n      neighbors[2] = node[up].node;\n    }\n  }\n\n  if (current.getPoint().y < rows - 1) {\n    const down = getIndex(current.getPoint().x, current.getPoint().y + 1, cols);\n\n    if (node[down].node.getPoint().type !== \"wall\") {\n      neighbors[3] = node[down].node;\n    }\n  }\n\n  if (current.getPoint().x > 0 && current.getPoint().y > 0) {\n    const topLeft = getIndex(current.getPoint().x - 1, current.getPoint().y - 1, cols);\n\n    if (node[topLeft].node.getPoint().type !== \"wall\") {\n      neighbors[4] = node[topLeft].node;\n    }\n  }\n\n  if (current.getPoint().x < cols - 1 && current.getPoint().y > 0) {\n    const topRight = getIndex(current.getPoint().x + 1, current.getPoint().y - 1, cols);\n\n    if (node[topRight].node.getPoint().type !== \"wall\") {\n      neighbors[5] = node[topRight].node;\n    }\n  }\n\n  if (current.getPoint().x > 0 && current.getPoint().y < rows - 1) {\n    const bottomLeft = getIndex(current.getPoint().x - 1, current.getPoint().y + 1, cols);\n\n    if (node[bottomLeft].node.getPoint().type !== \"wall\") {\n      neighbors[6] = node[bottomLeft].node;\n    }\n  }\n\n  if (current.getPoint().x < cols - 1 && current.getPoint().y < rows - 1) {\n    const bottomRight = getIndex(current.getPoint().x + 1, current.getPoint().y + 1, cols);\n\n    if (node[bottomRight].node.getPoint().type !== \"wall\") {\n      neighbors[7] = node[bottomRight].node;\n    }\n  }\n\n  return neighbors;\n}\n\nfunction BFS(rows, cols, gridMap, memState, setState) {\n  const [startPoint, endPoints] = getPoints(gridMap);\n  const queue = new FibonacciHeap();\n  const cameFrom = {};\n  const node = {};\n  const states = [];\n  return;\n}\n\nexport default BFS;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Algorithms/BFS.js"],"names":["FibonacciHeapNode","Node","getIndex","x","y","cols","getNeighbors","current","rows","node","neighbors","Array","getPoint","left","type","right","up","down","topLeft","topRight","bottomLeft","bottomRight","BFS","gridMap","memState","setState","startPoint","endPoints","getPoints","queue","FibonacciHeap","cameFrom","states"],"mappings":"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","sourcesContent":["import FibonacciHeapNode from '../Algorithms/FibonacciHeapNode';\n\nconst Node = FibonacciHeapNode;\n\nfunction getIndex(x, y, cols){\n    return (x + (y * cols));\n}\n\nfunction getNeighbors(current, rows, cols, node){\n    //Point                                 Index\n    // left point.x-1, point.y              (point.x-1) + (point.y * cols)\n    // right point.x+1, point.y             (point.x+1) + (point.y * cols)\n    // up point.x, point.y-1                (point.x) + (point.y-1 * cols)\n    // down point.x, point.y+1              (point.x) + (point.y+1 * cols)\n    // top left point.x-1, point.y-1        (point.x-1) + (point.y-1 * cols)\n    // top right point.x+1, point.y-1       (point.x+1) + (point.y-1 * cols)\n    // bottom left point.x-1, point.y+1     (point.x-1) + (point.y+1 * cols)\n    // bottom right point.x+1, point.y+1    (point.x+1) + (point.y+1 * cols)\n\n    const neighbors = new Array(8);\n    \n    if(current.getPoint().x > 0){\n        const left = getIndex((current.getPoint().x-1), (current.getPoint().y), cols);\n\n        if(node[left].node.getPoint().type !== \"wall\"){\n            neighbors[0] = node[left].node;   \n        }\n    }\n    if(current.getPoint().x < cols-1){\n        const right = getIndex((current.getPoint().x+1), (current.getPoint().y), cols);\n\n        if(node[right].node.getPoint().type !== \"wall\"){\n            neighbors[1] = node[right].node;   \n        }\n    }\n    if(current.getPoint().y > 0){\n        const up = getIndex((current.getPoint().x), (current.getPoint().y-1), cols);\n\n        if(node[up].node.getPoint().type !== \"wall\"){\n            neighbors[2] = node[up].node;   \n        }\n    }\n    if(current.getPoint().y < rows-1){\n        const down = getIndex((current.getPoint().x), (current.getPoint().y+1), cols);\n\n        if(node[down].node.getPoint().type !== \"wall\"){\n            neighbors[3] = node[down].node;   \n        }\n    }\n    if(current.getPoint().x > 0 && current.getPoint().y > 0){\n        const topLeft = getIndex((current.getPoint().x-1), (current.getPoint().y-1), cols);\n\n        if(node[topLeft].node.getPoint().type !== \"wall\"){\n            neighbors[4] = node[topLeft].node;   \n        }\n    }\n    if(current.getPoint().x < cols-1 && current.getPoint().y > 0){\n        const topRight = getIndex((current.getPoint().x+1), (current.getPoint().y-1), cols);\n\n        if(node[topRight].node.getPoint().type !== \"wall\"){\n            neighbors[5] = node[topRight].node;            \n        }\n    }\n    if(current.getPoint().x > 0 && current.getPoint().y < rows-1){\n        const bottomLeft  = getIndex((current.getPoint().x-1), (current.getPoint().y+1), cols);\n\n        if(node[bottomLeft].node.getPoint().type !== \"wall\"){\n            neighbors[6] = node[bottomLeft].node;   \n        }\n    }\n    if(current.getPoint().x < cols-1 && current.getPoint().y < rows-1){\n        const bottomRight = getIndex((current.getPoint().x+1), (current.getPoint().y+1), cols);\n\n        if(node[bottomRight].node.getPoint().type !== \"wall\"){\n            neighbors[7] = node[bottomRight].node;   \n        }\n    }\n\n    return neighbors;\n}\n\nfunction BFS(rows, cols, gridMap, memState, setState){\n    const [startPoint, endPoints] = getPoints(gridMap);\n    const queue = new FibonacciHeap();\n    const cameFrom = {};\n    const node = {};\n    const states = [];\n    return;\n}\n\nexport default BFS;"]},"metadata":{},"sourceType":"module"}