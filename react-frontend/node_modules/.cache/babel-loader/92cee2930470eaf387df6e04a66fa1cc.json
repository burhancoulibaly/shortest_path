{"ast":null,"code":"var _jsxFileName = \"/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js\";\nimport React, { useState, useContext, useEffect, useMemo, useRef, useCallback } from 'react';\nimport './Map.css';\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\nimport AStar from '../Algorithms/AStar';\n\nfunction Map(props) {\n  const {\n    menuState,\n    dispatch\n  } = useContext(MenuContext);\n  const [state, setState] = useState({\n    rows: 15,\n    cols: 50,\n    grid: new Array(15 * 50).fill({\n      val: false,\n      type: null\n    }).map((square, i) => {\n      return { ...square,\n        x: i % 50,\n        y: Math.abs((i - i % 50) / 50)\n      };\n    }),\n    //space-time O(1)\n    itemState: menuState.itemState,\n    openSet: [],\n    path: {},\n    canvasUpdated: true\n  });\n  const {\n    state: memState\n  } = useMemo(() => ({\n    state\n  }), [state]);\n  const runRef = useRef(menuState.run);\n  const canvasUpdatedRef = useRef(memState.canvasUpdated);\n  const openSetRef = useRef(memState.openSetRef);\n  const pathRef = useRef(memState.path);\n  runRef.current = menuState.run;\n  canvasUpdatedRef.current = memState.canvasUpdated;\n  openSetRef.current = memState.canvasUpdated;\n  pathRef.current = memState.canvasUpdated; //If item button is changed\n\n  useEffect(() => {\n    setState(memState => {\n      return { ...memState,\n        itemState: menuState.itemState\n      };\n    });\n  }, [menuState.itemState]); //If menu clear button is clicked\n\n  useEffect(() => {\n    if (menuState.clear === true) {\n      setState(memState => ({ ...memState,\n        grid: memState.grid.map(square => {\n          if (square.type !== \"start\" && square.type !== \"end\") {\n            return { ...square,\n              val: false,\n              type: null\n            };\n          }\n\n          return { ...square\n          };\n        })\n      }));\n      return dispatch({\n        type: \"cleared\"\n      });\n    }\n  }, [menuState.clear, dispatch]);\n  const updateCanvas = useCallback(() => {\n    if (runRef.current) {\n      console.log(runRef.current);\n      setState(memState => ({ ...memState,\n        canvasUpdated: false\n      }));\n      console.log(canvasUpdatedRef.current);\n    }\n\n    setTimeout(updateCanvas, 1);\n  }, [menuState.run]); //If run menu button is clicked\n\n  useEffect(() => {\n    if (runRef.current) {\n      console.log(openSetRef);\n      console.log();\n      setState(memState => ({ ...memState,\n        grid: memState.grid.map(square => {\n          if (square.type !== \"start\" && square.type !== \"end\" && square.type !== \"wall\") {\n            return { ...square,\n              val: false,\n              type: null\n            };\n          }\n\n          return { ...square\n          };\n        })\n      }));\n      updateCanvas(); //Visualize path finding algorithm logic\n\n      console.time();\n      AStar(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState);\n      console.timeEnd();\n      return dispatch({\n        type: \"complete\"\n      });\n    }\n  }, [menuState.run, menuState.heuristic, memState, updateCanvas, dispatch]);\n  useEffect(() => {\n    console.log(canvasUpdatedRef.current);\n\n    if (!canvasUpdatedRef.current) {\n      setState(memState => ({ ...memState,\n        //state object is immutable so updates have to be done this way\n        grid: memState.grid.map((square, index) => {\n          if (pathRef[index]) {\n            openSetRef.map(openSetPoint => {\n              if (openSetPoint.point.x + openSetPoint.point.y * memState.cols === index) {\n                square = memState.grid[openSetPoint.point.x + openSetPoint.point.y * memState.cols];\n\n                if (square.type !== \"start\" && square.type !== \"end\" && square.type !== \"path\" && square.type !== \"neighbors\") {\n                  memState.grid[openSetPoint.point.x + openSetPoint.point.y * memState.cols] = { ...square,\n                    val: true,\n                    type: \"openset\"\n                  }; // console.log(memState.grid[openSetPoint.point.x + (openSetPoint.point.y * memState.cols)])\n                }\n\n                return null;\n              }\n\n              return { ...memState.grid[openSetPoint.point.x + openSetPoint.point.y * memState.cols]\n              };\n            });\n\n            if (square.type !== \"start\" && square.type !== \"end\" && square.type !== \"path\" && square.type !== \"openset\") {\n              return { ...square,\n                val: true,\n                type: \"neighbors\"\n              };\n            }\n          }\n\n          if (square.type === \"end\") {\n            let cameFrom = pathRef[index];\n\n            while (cameFrom) {\n              square = memState.grid[cameFrom.x + cameFrom.y * memState.cols];\n\n              if (square.type !== \"start\" && square.type !== \"end\") {\n                memState.grid[cameFrom.x + cameFrom.y * memState.cols] = { ...square,\n                  val: true,\n                  type: \"path\"\n                };\n              }\n\n              cameFrom = pathRef[cameFrom.x + cameFrom.y * memState.cols];\n            }\n\n            return { ...memState.grid[index]\n            };\n          }\n\n          return { ...square\n          };\n        }),\n        canvasUpdated: true\n      }));\n    } // if(memState.path && memState.openSet){\n    // setTimeout(() => {\n    // }, 8000);\n    // }\n\n  }, [memState.canvasUpdated]);\n\n  const renderSquare = (x, y, val) => {\n    return /*#__PURE__*/React.createElement(Square //Minus 4 accounts for width and height\n    , {\n      width: memState.cols > memState.rows ? props.winDimensions.width / memState.cols - 4 : props.winDimensions.width / memState.cols * (Math.min(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows) / Math.max(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows)) - 4,\n      height: memState.rows === memState.cols ? props.winDimensions.height / memState.rows - 4 //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n      : props.winDimensions.height / memState.rows * (Math.min(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows) / Math.max(props.winDimensions.width / memState.cols, props.winDimensions.height / memState.rows)) - 4,\n      x: x,\n      y: y,\n      val: val,\n      squareClick: (x, y) => handleClick(x, y),\n      type: memState.grid[x + y * memState.cols].type,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 13\n      }\n    });\n  };\n\n  const renderMap = () => {\n    //TODO: use x y variables set per index for this instead\n    //space-time O(1)\n    const rows = Array(memState.rows); //each row will contain an array of 50 available indexes\n\n    const cols = Array(memState.rows); //time O(n)\n\n    for (let i = 0; i < memState.grid.length; i++) {\n      if (i % memState.cols === 0) {\n        cols[i / memState.cols] = Array(memState.cols); //space-time O(1)\n\n        rows[i] = /*#__PURE__*/React.createElement(\"div\", {\n          className: \"grid-row\",\n          key: i / memState.cols,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 208,\n            columnNumber: 21\n          }\n        }, cols[i / memState.cols]);\n      }\n\n      let square = /*#__PURE__*/React.createElement(\"div\", {\n        className: \"grid-col\",\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 215,\n          columnNumber: 17\n        }\n      }, renderSquare(i % memState.cols, Math.abs((i - i % memState.cols) / memState.cols), memState.grid[i].val));\n      cols[(i - i % memState.cols) / memState.cols][i % memState.cols] = square;\n    }\n\n    const map = rows;\n    return map;\n  };\n\n  const handleClick = (x, y) => {\n    switch (memState.itemState) {\n      case \"start\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,memState.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            if (square.type === memState.itemState && square.val && !memState.grid[x + y * memState.cols].val) {\n              return { ...square,\n                val: false,\n                type: null\n              };\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"wall\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      case \"end\":\n        setState(memState => ({ ...memState,\n          //state object is immutable so updates have to be done this way\n          grid: memState.grid.map((square, index) => {\n            if (index === x + y * memState.cols) {\n              // console.log(x,y,square.type,state.itemState);\n              if (square.type === memState.itemState || !square.val) {\n                return square.val ? { ...square,\n                  val: false,\n                  type: null\n                } : { ...square,\n                  val: true,\n                  type: memState.itemState\n                };\n              }\n            }\n\n            if (square.type === memState.itemState && square.val && !memState.grid[x + y * memState.cols].val) {\n              return { ...square,\n                val: false,\n                type: null\n              };\n            }\n\n            return { ...square\n            };\n          })\n        }));\n        break;\n\n      default:\n        break;\n    }\n\n    return;\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    id: \"map\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 308,\n      columnNumber: 9\n    }\n  }, console.time(), renderMap(), console.timeEnd());\n}\n\nexport default Map;","map":{"version":3,"sources":["/home/menekou/projects/react/shortest-path/react-frontend/src/Map/Map.js"],"names":["React","useState","useContext","useEffect","useMemo","useRef","useCallback","Square","MenuContext","AStar","Map","props","menuState","dispatch","state","setState","rows","cols","grid","Array","fill","val","type","map","square","i","x","y","Math","abs","itemState","openSet","path","canvasUpdated","memState","runRef","run","canvasUpdatedRef","openSetRef","pathRef","current","clear","updateCanvas","console","log","setTimeout","time","heuristic","timeEnd","index","openSetPoint","point","cameFrom","renderSquare","winDimensions","width","min","height","max","handleClick","renderMap","length"],"mappings":"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","sourcesContent":["import React, { useState, useContext, useEffect, useMemo, useRef, useCallback } from 'react';\nimport './Map.css';\nimport Square from '../Square/Square';\nimport MenuContext from '../MenuContext';\nimport AStar from '../Algorithms/AStar'\n\nfunction Map(props) {\n    const {menuState, dispatch} = useContext(MenuContext);\n    const [state, setState] = useState({\n        rows: 15,\n        cols: 50,\n        grid: new Array(15*50).fill({val: false, type: null}).map((square, i) => {\n            return {\n                ...square,\n                x: i % 50,\n                y: Math.abs((i - (i % 50)) / 50)\n            }\n        }),//space-time O(1)\n        itemState: menuState.itemState,\n        openSet: [],\n        path: {},\n        canvasUpdated: true\n    })\n\n    const { state: memState } = useMemo(() => ({state}), [state])\n\n    const runRef = useRef(menuState.run);\n    const canvasUpdatedRef = useRef(memState.canvasUpdated);\n    const openSetRef = useRef(memState.openSetRef);\n    const pathRef = useRef(memState.path);\n\n    runRef.current = (menuState.run);\n    canvasUpdatedRef.current = (memState.canvasUpdated);\n    openSetRef.current = (memState.canvasUpdated);\n    pathRef.current = (memState.canvasUpdated);\n\n    //If item button is changed\n    useEffect(() => {\n        setState((memState) => {\n            return {\n                ...memState,\n                itemState: menuState.itemState\n            }\n        })\n    }, [menuState.itemState]);\n\n    //If menu clear button is clicked\n    useEffect(() => {\n        if(menuState.clear === true){\n            setState((memState) => ({\n                ...memState,\n                grid: memState.grid.map((square) => {\n                    if(square.type !== \"start\" && square.type !== \"end\"){\n                        return {...square, val: false, type: null}\n                    }\n            \n                    return {...square}\n                })\n            }))\n            return dispatch({type: \"cleared\"});\n        }\n    }, [menuState.clear, dispatch]);\n    \n    const updateCanvas = useCallback(() => {\n        if(runRef.current){\n            console.log(runRef.current)\n            setState((memState) => ({\n                ...memState,\n                canvasUpdated: false\n            }))\n            console.log(canvasUpdatedRef.current)\n        }\n        \n        setTimeout(updateCanvas, 1);\n    },[menuState.run])\n\n    //If run menu button is clicked\n    useEffect(() => {\n        if(runRef.current){\n            console.log(openSetRef);\n            console.log()\n            setState((memState) => ({\n                ...memState,\n                grid: memState.grid.map((square) => {\n                    if(square.type !== \"start\" && square.type !== \"end\" && square.type !== \"wall\"){\n                        return {...square, val: false, type: null}\n                    }\n            \n                    return {...square}\n                })\n            }))\n\n            updateCanvas();\n\n            //Visualize path finding algorithm logic\n            console.time()\n            AStar(memState.rows, memState.cols, memState.grid, menuState.heuristic, memState, setState);\n            console.timeEnd()         \n            \n            return dispatch({type: \"complete\"});\n        }\n    }, [menuState.run, menuState.heuristic, memState, updateCanvas, dispatch]);\n\n    useEffect(() => {\n        console.log(canvasUpdatedRef.current);\n        if(!canvasUpdatedRef.current){\n            setState((memState) => ({\n                ...memState,\n                //state object is immutable so updates have to be done this way\n                grid: memState.grid.map((square, index) => {\n                    if(pathRef[index]){\n                        openSetRef.map((openSetPoint) => {\n                            if(openSetPoint.point.x + (openSetPoint.point.y * memState.cols) === index){\n                                square = memState.grid[openSetPoint.point.x + (openSetPoint.point.y * memState.cols)];\n        \n                                if(square.type !== \"start\" && square.type !== \"end\"  && square.type !== \"path\" && square.type !== \"neighbors\"){\n                                    memState.grid[openSetPoint.point.x + (openSetPoint.point.y * memState.cols)] = {\n                                        ...square,\n                                        val: true,\n                                        type: \"openset\"\n                                    }\n        \n                                    // console.log(memState.grid[openSetPoint.point.x + (openSetPoint.point.y * memState.cols)])\n                                }\n        \n                                return null;\n                            }\n        \n                            return {...memState.grid[openSetPoint.point.x + (openSetPoint.point.y * memState.cols)]}\n                        })\n    \n    \n                        if(square.type !== \"start\" && square.type !== \"end\" && square.type !== \"path\" && square.type !== \"openset\"){\n                            return {...square, val: true, type: \"neighbors\"};\n                        }\n                    }\n    \n                    if(square.type === \"end\"){\n                        let cameFrom = pathRef[index];\n    \n                        while(cameFrom){\n                            square = memState.grid[cameFrom.x + (cameFrom.y * memState.cols)];\n                            \n                            if(square.type !== \"start\" && square.type !== \"end\"){\n                                memState.grid[cameFrom.x + (cameFrom.y * memState.cols)] = {\n                                    ...square,\n                                    val: true,\n                                    type: \"path\"\n                                }\n                            }\n    \n                            cameFrom = pathRef[cameFrom.x + (cameFrom.y * memState.cols)];\n                        }\n                        \n                        return {...memState.grid[index]};\n                    }\n    \n                    return {...square};\n                }),\n                canvasUpdated: true\n            }));\n        }\n        \n        // if(memState.path && memState.openSet){\n            // setTimeout(() => {\n                \n            // }, 8000);\n        // }\n    },[ memState.canvasUpdated]);\n    \n    const renderSquare = (x,y,val) => {\n        return (\n            <Square\n                //Minus 4 accounts for width and height\n                width={\n                    memState.cols > memState.rows\n                        ? (props.winDimensions.width / memState.cols) - 4\n                        : (props.winDimensions.width / memState.cols) * (Math.min((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows)) / Math.max((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows))) - 4 \n                }\n                height={\n                    memState.rows === memState.cols\n                        ? (props.winDimensions.height / memState.rows) - 4\n                        //converting aspect ration of the square to 1:1 by multiplying the height by minimum of the width and height divided by the maximum of the width and height\n                        : (props.winDimensions.height / memState.rows) * (Math.min((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows)) / Math.max((props.winDimensions.width / memState.cols),(props.winDimensions.height / memState.rows))) - 4\n                }\n                x={x}\n                y={y}\n                val={val}\n                squareClick={(x, y) => handleClick(x, y)}\n                type={memState.grid[x + (y * memState.cols)].type}\n            />\n        )\n    }\n\n    const renderMap = () => {\n        //TODO: use x y variables set per index for this instead\n        //space-time O(1)\n        const rows = Array(memState.rows);\n        //each row will contain an array of 50 available indexes\n        const cols = Array(memState.rows);\n\n        //time O(n)\n        for(let i = 0; i < memState.grid.length; i++){\n            if(i % memState.cols === 0){\n                cols[i / memState.cols] = Array(memState.cols)//space-time O(1)\n\n                rows[i] = (\n                    <div className=\"grid-row\" key={i / memState.cols}>\n                        {cols[i / memState.cols]}\n                    </div>\n                )\n            }\n\n            let square = (\n                <div className=\"grid-col\" key={i}>\n                    {renderSquare(i % memState.cols, Math.abs((i - (i % memState.cols)) / memState.cols), memState.grid[i].val)}\n                </div>\n            )\n\n            cols[(i - (i % memState.cols)) / memState.cols][i % memState.cols] = square;\n        }\n\n        const map = rows;\n\n        return map;\n    }\n\n    const handleClick = (x,y) => {\n        switch (memState.itemState) {\n            case \"start\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,memState.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        if(square.type === memState.itemState && square.val && !memState.grid[x + (y * memState.cols)].val){\n                            return {...square, val: false, type: null}\n                        }\n\n                        return {...square}\n                    })\n                }));\n                \n                break;\n\n            case \"wall\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n\n            case \"end\":\n                setState((memState) => ({\n                    ...memState,\n                    //state object is immutable so updates have to be done this way\n                    grid: memState.grid.map((square, index) => {\n                        if(index === x + (y * memState.cols)){\n                            // console.log(x,y,square.type,state.itemState);\n                            if(square.type === memState.itemState || !square.val){\n                                return square.val\n                                    ? {...square, val: false, type: null}\n                                    : {...square, val: true, type: memState.itemState}\n                            }\n                        }\n\n                        if(square.type === memState.itemState && square.val && !memState.grid[x + (y * memState.cols)].val){\n                            return {...square, val: false, type: null}\n                        }\n\n                        return {...square}\n                    })\n                }));\n\n                break;\n        \n            default:\n                break;\n        }\n\n        return;\n    }\n    \n\n\n    return (\n        <div id=\"map\">\n            {console.time()}\n                {renderMap()}\n            {console.timeEnd()}\n        </div>\n    )\n}\n\nexport default Map;"]},"metadata":{},"sourceType":"module"}